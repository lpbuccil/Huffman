/**
 * Name:  Lucas Buccilli
 * Assignment number:  5
 * Class: CS2321
 * Description: Compress text file with huffman encoding and decompresses huffman encoded file into text file.
 */

package cs2321;

import net.datastructures.Entry;
import net.datastructures.Position;

import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;


/*
 * The format of the compressed file includes 3 continuously parts:
 *  1. prefix tree in bit stream
 *  2. length of the original file using 4 bytes
 *  3. data coded with Huffman coding. 
 * 
 * Encoding prefix tree bit stream: 
 *   if the node is external, output 0, followed by the letter
 *   if the node is internal, output 1, followed by 
 *  		the bit stream of left subtree, then the bit stream of right subtree. 
 */
class Huffman {

    private LinkedBinaryTree t = new LinkedBinaryTree();
    private String[] CODE_TABLE = new String[256];
    private String outputfile = "";
    private BufferedWriter bufferedWriter;
    private ArrayList<Byte> arrayListOutputByte = new ArrayList<>();
    private int[] byteArray = new int[8];
    //For decompress
    private int bitCount;
    private ArrayList<Integer> inputBinaryArray;
    //For compress
    private int bitCounter;

    private Huffman() {
    }

    /**
     * Decode the compressed data file back to the original data file.
     *
     * @param //inputFile  : the compressed file
     * @param //outputFile : the file that should be generated by the decode function using ascii code.
     */
    public static void main(String[] args) {
        Huffman huffman = new Huffman();
        int length;

        // db.txt has only two letters "ab". The length with Huffman coding should be 2.
        length = huffman.compress("ab.txt", "ab.txt.huffman");
        System.out.println("length is " + length);

        // decode your newly created compress file. The generated file "ab.txt.decoded" should have same content as "ab.txt"
        huffman.decode("abra.txt.huffman", "abra.txt.decoded");


        // decode the previous correctly compressed file by instructor.  The generated file "ab.txt.decoded" should have content as "ab.txt"
        huffman.decode("ab.txt.compressed", "ab.txt.decoded");

        huffman.compress("test1.txt", "test1.txt.compressed");
        huffman.decode("test1.txt.compressed", "test1.txt.decompressed");

        huffman.compress("tinytinyTale.txt", "tinytinyTale.txt.compressed");
        huffman.decode("tinytinyTale.txt.compressed", "tinytinyTale.txt.decompressed");

        // You may perform the above same testing for other files, like abra.txt, gogo.txt, tinytinyTable.txt

    }

    /**
     * Compress file using Huffman code.
     *
     * @param inputFile  The original data file
     * @param outputFile The compressed data file that should be generated.
     * @return the length of the data encoded with Huffman Code, don't include data for the prefix tree and length of the original file.
     */
    @TimeComplexity("O(n log n)")
    private int compress(String inputFile, String outputFile) {


        t = new LinkedBinaryTree();
        CODE_TABLE = new String[256];
        outputfile = "";

        arrayListOutputByte = new ArrayList<>();
        byteArray = new int[8];
        bitCount = 0;
        bitCounter = 0;

        String inputFileString = "";
        char[] inputFileCharacterArray = null;
        FileReader fileReader;


        //Read all text from file and store it in inputFileString then add all char to inputFileCharArray
        try {
            fileReader = new FileReader(inputFile);
            while (fileReader.ready()) {
                // System.out.println((char) fileReader.read());
                inputFileString += (char) fileReader.read();
            }

            //remove and windows char
            //inputFileString = inputFileString.replace("\r", "").replace("\n", "");
            inputFileCharacterArray = inputFileString.toCharArray();
            fileReader.close();
        } catch (Exception e) {
            System.out.println("ERROR: Cannot read file");
        }


        //Calculate frequency of chars
        int[] frequencyOfChars = new int[256];
        for (int i = 0; i < inputFileCharacterArray.length; i++) {
            frequencyOfChars[inputFileCharacterArray[i]]++;
        }


        //Create huffman tree
        LinkedBinaryTree<Character> huffmanTree = buildPrefixTree(frequencyOfChars);

        buildCodeTable(huffmanTree.root(), "");

        //Set for use in other method
        outputfile = outputFile;

        FileWriter fileWriter = null;

        try {
            fileWriter = new FileWriter(outputfile);
            bufferedWriter = new BufferedWriter(fileWriter);

        } catch (IOException e) {
            System.out.println("ERROR: Cannot write file");
        }


        //Writes tree to file
        for (Position node : huffmanTree.positions()) {

            if (huffmanTree.isInternal(node)) {
                writeBit(1);
            }
            if (huffmanTree.isExternal(node)) {
                writeBit(0);


                //write ascii in binary to array
                int asciiValue = (int) (Character) node.getElement();
                int mask = 1 << 7; //1000 0000
                for (int i = 0; i < 8; i++) {

                    int bit = asciiValue & mask;

                    if (bit > 0) {
                        writeBit(1);
                    } else {
                        writeBit(0);
                    }

                    mask = mask >> 1;

                }

            }

        }


        //get length of data
        int lengthOfData = inputFileString.length();


        //Create binary string of int length
        String result = Long.toBinaryString(Integer.toUnsignedLong(lengthOfData) | 0x100000000L).substring(1);


        //writ bits of binary length
        for (int t = 0; t < result.length(); t++) {
            if (result.charAt(t) == '1') {
                writeBit(1);
            } else {
                writeBit(0);
            }
        }


        //Write encoded data
        for (int k = 0; k < inputFileCharacterArray.length; k++) {
            String code = CODE_TABLE[(int) inputFileCharacterArray[k]];
            for (int j = 0; j < code.length(); j++) {
                if (code.charAt(j) == '0') {
                    writeBit(0);
                } else {
                    writeBit(1);
                }
            }
        }


        //Flush buffer, pads with 0's
        while (bitCount != 0) {
            writeBit(0);
        }

        //write array to file
        writeFile();
        try {
            bufferedWriter.close();
            fileWriter.close();
        } catch (IOException e) {
            System.out.println("ERROR: Cannot close bufferedWriter or fileWriter, file may not save");
        }


        return lengthOfData;
    }

    /**
     * Adds a bit to the buffer, if buffer is full, adds byte to output array
     *
     * @param input int 1 or 0
     */
    private void writeBit(int input) {

        byteArray[bitCount] = input;
        bitCount++;

        if (bitCount == 8) {
            int offset = 7;
            int mask = 1;
            int b = 0;
            for (int i : byteArray) {
                if (i == 0) {
                    offset--;
                }
                if (i == 1) {


                    b = b | (mask << offset);
                    offset--;
                }
            }
            //System.out.println(b);
            arrayListOutputByte.addLast((byte) b);
            bitCount = 0;
            byteArray = new int[8];


        }

    }


    /**
     * Writes to the file from output array
     */
    private void writeFile() {
        byte[] outputByteArray = new byte[arrayListOutputByte.size()];

        for (int i = 0; i < arrayListOutputByte.size(); i++) {
            outputByteArray[i] = arrayListOutputByte.get(i);
        }

        try {
            Files.write(Paths.get(outputfile), outputByteArray);
        } catch (IOException e) {
            System.out.println("ERROR: Cannot write file");
        }
    }

    /**
     * builds huffman tree.
     *
     * @param //frequency array A
     * @return huffman tree
     */
    private LinkedBinaryTree<Character> buildPrefixTree(int[] A) {

        HeapPQ<Integer, LinkedBinaryTree<Character>> PQ = new HeapPQ<>();

        //create new tree size 1 for each element in freq array and insert it to priority queue
        for (char i = 0; i < 256; i++) {
            if (A[i] > 0) {
                t = new LinkedBinaryTree<>();
                t.addRoot(i);
                PQ.insert(A[i], t);
            }
        }

        //combine linked binary trees of min key into combined linked binary tree until only 1 tree left in pq
        while (PQ.size() > 1) {
            Entry<Integer, LinkedBinaryTree<Character>> e1 = PQ.removeMin();
            Entry<Integer, LinkedBinaryTree<Character>> e2 = PQ.removeMin();
            int combinedFreq = e2.getKey() + e1.getKey();
            t = new LinkedBinaryTree<Character>();
            t.addRoot((char) 0);
            t.attach(t.root(), e1.getValue(), e2.getValue());
            PQ.insert(combinedFreq, t);
        }
        return PQ.min().getValue();
    }


    /**
     * builds hiffman code table
     *
     * @param V    root node of huffman tree
     * @param code
     */
    private void buildCodeTable(Position<Character> V, String code) {
        if (t.isExternal(V)) {
            CODE_TABLE[V.getElement()] = code;
        } else {
            buildCodeTable(t.left(V), code + "0");
            buildCodeTable(t.right(V), code + "1");
        }

    }

    /**
     * Decodes huffman encoded file
     *
     * @param inputFile  huffman encoded file
     * @param outputFile plain text file
     */
    @TimeComplexity("O(n log n)")
    private void decode(String inputFile, String outputFile) {

        t = new LinkedBinaryTree();
        CODE_TABLE = new String[256];
        outputfile = "";

        arrayListOutputByte = new ArrayList<>();
        byteArray = new int[8];
        bitCount = 0;
        bitCounter = 0;


        //Create byte array to store file in bytes
        byte[] inputBytes = null;


        //ready all bytes from file into arraylist
        try {
            inputBytes = Files.readAllBytes(Paths.get(inputFile));
        } catch (Exception e) {
            System.out.println("ERROR: Cannot read file");
        }

        //Convert each byte from inputBytes array to binary string and add to array list
        ArrayList<String> inputStringBytes = new ArrayList<>();
        for (byte b : inputBytes) {
            inputStringBytes.addLast(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));
        }


        //Convert binary strings in arraylist to its binary form then adds 1's and 0's to inputBinaryArray
        inputBinaryArray = new ArrayList<>();
        for (String s : inputStringBytes) {
            for (int i = 0; i < 8; i++) {
                inputBinaryArray.addLast(Integer.parseInt(String.valueOf(s.charAt(i))));
            }
        }


        //Create huffman tree for decoding
        LinkedBinaryTree<Character> huffmanTree = readPrefixTree();


        //read 4 bytes for length
        int byte1 = readNextByte();
        int byte2 = readNextByte();
        int byte3 = readNextByte();
        int byte4 = readNextByte();


        //convert 4 bytes to 32 bit word
        String dataLengthString =
                String.format("%8s", Integer.toBinaryString(byte1)).replace(' ', '0') +
                        String.format("%8s", Integer.toBinaryString(byte2)).replace(' ', '0') +
                        String.format("%8s", Integer.toBinaryString(byte3)).replace(' ', '0') +
                        String.format("%8s", Integer.toBinaryString(byte4)).replace(' ', '0');


        //Parse binary string into int
        int dataLengthInt = Integer.parseInt(dataLengthString, 2);


        //Arraylist stores decoded chars
        ArrayList<Character> outputCharArrayList = new ArrayList<>();

        //Decode all chars binaryarray with huffman tree and stores them in output array
        for (int i = 0; i < dataLengthInt; i++) {
            Position V = huffmanTree.root();
            while (huffmanTree.isInternal(V)) {
                int b = getNextBit();
                if (b == 0) {
                    V = huffmanTree.left(V);
                } else {
                    V = huffmanTree.right(V);
                }
            }
            outputCharArrayList.addLast((Character) V.getElement());
        }


        //convert output array list to array
        char[] outputCharArray = new char[outputCharArrayList.size()];
        for (int k = 0; k < outputCharArray.length; k++) {
            outputCharArray[k] = outputCharArrayList.get(k);
        }

        //write file from output array
        try {
            FileWriter fileWriter = new FileWriter(outputFile);

            fileWriter.write(outputCharArray);

            fileWriter.close();
        } catch (Exception e) {
            System.out.println("ERROR: Cannot write or close file.");
        }


    }

    /**
     * Creates huffman tree from huffman encoded file
     *
     * @return huffman tree
     */
    private LinkedBinaryTree<Character> readPrefixTree() {
        //b - bit
        int b = getNextBit();

        //Is external
        if (b == 0) {
            char letter = (char) readNextByte();
            LinkedBinaryTree<Character> t = new LinkedBinaryTree<>();
            t.addRoot(letter);
            return t;
            //is internal
        } else {
            LinkedBinaryTree<Character> t1 = readPrefixTree();
            LinkedBinaryTree<Character> t2 = readPrefixTree();
            LinkedBinaryTree<Character> t = new LinkedBinaryTree<>();
            t.addRoot((char) 0);
            t.attach(t.root(), t1, t2);
            return t;
        }

    }

    /**
     * @return next bit in from file
     */
    private int getNextBit() {
        int temp = inputBinaryArray.get(bitCounter);
        bitCounter++;

        return temp;
    }

    /**
     * @return next byte
     */
    private int readNextByte() {
        String temp = "";
        for (int i = 0; i < 8; i++) {
            temp += getNextBit();
        }
        return Integer.parseInt(temp, 2);
    }


}
